/*
 * Davis Instruments Corporation
 * WeatherLink 2.0 Chart Application
 *
 * Define Application Plot Chart Sensor Data Panel Module
 */
var wl = wl || {};

wl.app.module('BulletinTilePanel', function(oPanel, oApp) {

  oPanel.startWithParent = false;
  
  oPanel.RightPanelView = wl.davis.views.RightPanelView;

  oPanel.NodeListView = Marionette.ItemView.extend({
    template: window.tpl['bulletin-panel-template'],
    initialize: function() {
    },
    ui: {
      accordion: ".js-accordion",
      save: ".btn.btn-save",
      clear: ".clear-all",
      selectAll: ".select-all",
      tileOption: ".js-tile-option",
      expand: ".js-expand",
      collapse: ".js-collapse",
      panel: ".right-panel-content"
    },
    events: {
      "click @ui.save": "save",
      "click @ui.clear": "clear",
      "click @ui.selectAll": "selectAll",
      "click @ui.expand": "expand",
      "click @ui.collapse": "collapse",
      "click @ui.tileOption": "highlight"
    },
    highlight: function(state) {
      if (state) {
        this.ui.save.closest('div').addClass('active');
      } else {
        this.ui.save.closest('div').removeClass('active');
      }
    },
    save: function() {

      //make save button disabled
      this.highlight(false);

      var oTileView;
      wl.data.portletConfigs.each(function(oConfig) {

        $(".js-tile-option").each(function() {
          if (oConfig.get("iPortletSettingId") === Number($(
              this).attr("data-portSetId"))) {

            //Get the tileView object
            oTileView = oApp.Dashboard.getSpecificTiles(
              oConfig.get("sTileCid"));
            var bTileVisible = oConfig.get("iVisible");
            var bIsChecked = $(this).is(':checked');
            //compare to see
            //found matching option with the config
            if (bIsChecked && !bTileVisible) {

              //Checkbox is checked and tile was NOT visible.
              //So make tile visible.
              oConfig.set("iVisible", 1);
              //Add the portlet back
              oApp.Dashboard.addPortlet(oConfig);
              oConfig.save();
            } else if (!bIsChecked && bTileVisible) {

              //checbox is NOT checked and tile was visible
              //So we need to hide the tile
              //This trigger of the View will handle all the needed functions
              //dashboard.js > _hideTile
            	if(oTileView != null && !$(this).closest('.wl-checkbox').hasClass('hidden')) {
                oTileView.trigger('cmd:hide');
            	}
            }

            oApp.Dashboard.trigger('tile:repack');
            //Don't need to do anything if case doesn't fall into one of the if cases.

            return false;
          }
        }); //.js-title-option
      }); //wl.data.portletConfigs

    },
    clear: function() {
      //Uncheck all the options
      $(".js-tile-option").prop("checked", false);
      //Make Apply button default state
      this.highlight(false);
      this.save();
    },
    selectAll: function() {
      //Check all the options
      $(".js-tile-option").prop("checked", true);
      //Make Apply button highlighted
      this.highlight(true);
    },
    expand: function() {
      this.ui.expand.children().removeClass(
        "glyphicon glyphicon-triangle-bottom").addClass(
        "glyphicon glyphicon-triangle-top");
      $(".ui-accordion-header").toggleClass("ui-corner-all", false).toggleClass(
        "ui-accordion-header-active ui-state-active ui-corner-top",
        true).attr({
        "aria-selected": true
      });
      $(".ui-accordion-header-icon").toggleClass(
        "ui-icon-triangle-1-e", false).toggleClass(
        "ui-icon-triangle-1-s", true);
      $(".ui-accordion-content").addClass(
        "ui-accordion-content-active").attr({
        "aria-expanded": true,
        "aria-hidden": false
      }).slideDown();
      this.ui.expand.toggleClass("js-expand", false).toggleClass(
        "js-collapse", true);
    },
    collapse: function() {
      this.ui.collapse = this.$el.find(".js-collapse");
      this.ui.collapse.children().removeClass(
        "glyphicon glyphicon-triangle-top").addClass(
        "glyphicon glyphicon-triangle-bottom");
      $(".ui-accordion-header").toggleClass("ui-corner-all", true).toggleClass(
        "accordion-header-active ui-state-active ui-corner-top",
        false).attr({
        "aria-selected": false
      });
      $(".ui-accordion-header-icon").toggleClass(
        "ui-icon-triangle-1-e", true).toggleClass(
        "ui-icon-triangle-1-s", false);
      $(".ui-accordion-content").removeClass(
        'ui-accordion-content-active').attr({
        "aria-expanded": false,
        "aria-hidden": true
      }).hide();
      this.ui.collapse.toggleClass("js-collapse", false).toggleClass(
        "js-expand", true);
    },
    onRender: function() {
      this.ui.panel.perfectScrollbar();
      var $panel = this.ui.panel;
      var slideCb = function () {
        $panel.perfectScrollbar && $panel.perfectScrollbar('update');
      };
      var currHeader, currContent;
      // Accordion widget setup
      this.ui.accordion.accordion({
        "collapsible": true,
        "active": false,
        "heightStyle": "content",
        "beforeActivate": function(event, ui) {
          // The accordion believes a panel is being opened
          if (ui.newHeader[0]) {
            currHeader = ui.newHeader;
            currContent = currHeader.next(
              '.ui-accordion-content');
            // The accordion believes a panel is being closed
          } else {
            currHeader = ui.oldHeader;
            currContent = currHeader.next(
              '.ui-accordion-content');
          }
          // Since we've changed the default behavior, this detects the actual status
          var isPanelSelected = currHeader.attr('aria-selected') ===
            'true';
          // Toggle the panel's header
          currHeader.toggleClass('ui-corner-all',
            isPanelSelected).toggleClass(
            'accordion-header-active ui-state-active ui-corner-top', !
            isPanelSelected).attr('aria-selected', ((!
            isPanelSelected).toString()));
          // Toggle the panel's icon
          currHeader.children('.ui-accordion-header-icon').toggleClass(
            'ui-icon-triangle-1-e', isPanelSelected).toggleClass(
            'ui-icon-triangle-1-s', !isPanelSelected);
          // Toggle the panel's content
          currContent.toggleClass('accordion-content-active', !
            isPanelSelected);
          if (isPanelSelected) {
            currContent.slideUp(null, slideCb);
          } else {
            currContent.slideDown(null, slideCb);
          }
          return false; // Cancels the default action
        }
      });
      if (wl.data.tilePanelData != null && wl.data.isOwner) {
          this.buildTileList();
      }
    },
    buildTileList: function () {
        var sensorListHtml = "";
        var tileData = wl.data.tilePanelData;
        var gatewayLabels = ['gw', 'wll', 'ip', 'dl', 'vc'];
        for (var i in tileData) {
            if (tileData.hasOwnProperty(i)) {
                var sensors = tileData[i].sensors;
                var nodeIconLabel = tileData[i].nodeIconLabel;
                var nodeIconClass = "port-icon icon-" + nodeIconLabel;
                var nodeIconTooltipName = tileData[i].nodeIconTooltip;
                var nodeName = tileData[i].nodeName;
                
                var bShowStaleIcon = false;
                var sFormattedTime = "--";
                var tzOffsetSec = 0;
                
                //Weather Station and Extra Sensors
                if ((nodeIconLabel === 'ws' || nodeIconLabel === 'es') && wl.data.stationData != null) {
                    tzOffsetSec = wl.data.timezoneOffset * 60;
                    var loopHatLocal = wl.data.stationData.time_stamp + tzOffsetSec;
                    sFormattedTime = wl.app.oMapper.formatHappenedAtDateTime(
                        wl.data.stationData.time_stamp, tzOffsetSec);
                    bShowStaleIcon = wl.app.oMapper.checkLastUpdatedTime(
                        loopHatLocal, wl.data.staleDataBufferSec);
                }
                
                //Gateway
                if (_.includes(gatewayLabels, nodeIconLabel) && wl.data.barometerData != null 
                        && wl.data.barometerData.lastUpdatedTs != null) {
                    tzOffsetSec = wl.data.barometerData.tzOffsetSec;
                    var iHat = wl.data.barometerData.lastUpdatedTs;
                    var sensorLastUpdated = iHat + tzOffsetSec;
                    sFormattedTime = wl.app.oMapper.formatHappenedAtDateTime(iHat, tzOffsetSec);
                    bShowStaleIcon = wl.app.oMapper.checkLastUpdatedTime(
                      sensorLastUpdated, wl.data.staleDataBufferSec);
                }
                
                //EM Node
                if (nodeIconLabel === 'nd') {
                    var tsArr = [];
                    for (var y in sensors) {
                        if (sensors.hasOwnProperty(y)) {
                            var sensorLsid = _.get(_.find(sensors[y].tiles), 'logicalSensorId');
                            var sensorObj = wl.app.Dashboard.getMaiaLogicalSensorByLsid(sensorLsid);
                            var sensorHat = Utils.getSensorHat(sensorObj);
                            var sensorTzOffset = Utils.getSensorOffset(sensorObj);
                            tsArr.push({sensorHat: sensorHat, sensorTzOffset: sensorTzOffset});
                        }
                    }
                    //find latest timestamp
                    if (tsArr.length > 0) {
                        var latestTsObj = tsArr.reduce(function(prev, current) {
                            return (prev.sensorHat + prev.sensorTzOffset > current.sensorHat + current.sensorTzOffset) ? prev : current
                        })
                        var latestTs = latestTsObj.sensorHat + latestTsObj.sensorTzOffset;
                        var sFormattedTime = "--";

                        if (latestTs !== 0 && wl.app.oMapper.checkLastUpdatedTime(
                            latestTs, wl.data.staleDataBufferSec)) {
                          sFormattedTime = wl.app.oMapper.formatHappenedAtDateTime(latestTsObj.sensorHat,
                              latestTsObj.sensorTzOffset);
                          bShowStaleIcon = true;
                        }
                    }
                }
                
                //AirLink
                if (nodeIconLabel === 'al') {
                	var key = _.keys(sensors)[0];
                	var tiles = sensors[key].tiles;
                	var lsid = _.get(_.find(tiles, 'logicalSensorId'), 'logicalSensorId');
                	if (wl.data.aqsSensorData[lsid] && wl.data.aqsSensorData[lsid].additionalData) {
                		var iHat = wl.data.aqsSensorData[lsid].additionalData.lastUpdated;
                  	var timezone = wl.data.aqsSensorData[lsid].additionalData.tz;
                  	var tzOffset = dayjs().tz(timezone).utcOffset()*60;
                		var sensorLastUpdated = iHat + tzOffset;
                		sFormattedTime = wl.app.oMapper.formatHappenedAtDateTime(iHat, tzOffset);
                    bShowStaleIcon = wl.app.oMapper.checkLastUpdatedTime(
                      sensorLastUpdated, wl.data.staleDataBufferSec);
                  }
                }
                
                //Ports
                if (!_.isNaN(parseInt(nodeIconLabel))) {
                    var lsid = Number(_.keys(sensors)[0]);
                    var logicalSensor = wl.app.Dashboard.getMaiaLogicalSensorByLsid(lsid);
                    var bShowStaleIcon = false;
                    var tzOffset = Utils.getSensorOffset(logicalSensor);
                    var iHat = Utils.getSensorHat(logicalSensor);
                    var sensorLastUpdated = iHat + tzOffset;
                    var sFormattedTime = "--";

                    if (sensorLastUpdated !== 0 && wl.app.oMapper.checkLastUpdatedTime(
                        sensorLastUpdated, wl.data.staleDataBufferSec)) {
                      sFormattedTime = wl.app.oMapper.formatHappenedAtDateTime(iHat,
                        tzOffset);
                      bShowStaleIcon = true;
                    }
                }
                
                if (bShowStaleIcon) {
                    nodeIconClass += " stale-icon";
                }
                
                var nodeIconHtml = this.createPortIconHtml(nodeIconClass, bShowStaleIcon, sFormattedTime, nodeIconTooltipName);
                sensorListHtml += "<h3>" + nodeIconHtml + "<span class='accordion-txt' data-l10n-id='"+ nodeName +"'>" +
                		"</span><i class='wl-icon icon-carretdown'></i><i class='wl-icon icon-carretup'></i><h3><div>";
                
                for (var j in sensors) {
                    if (sensors.hasOwnProperty(j)) {
                        var sensorName = sensors[j].sensorName;
                        if (sensorName != null) {
                            var lsid = _.get(_.find(sensors[j].tiles), 'logicalSensorId');
                            var logicalSensor = wl.app.Dashboard.getMaiaLogicalSensorByLsid(lsid);
                            var bShowStaleIcon = false;
                            var tzOffset = Utils.getSensorOffset(logicalSensor);
                            var iHat = Utils.getSensorHat(logicalSensor);
                            var sensorLastUpdated = iHat + tzOffset;
                            var sFormattedTime = "--";

                            if (sensorLastUpdated !== 0 && wl.app.oMapper.checkLastUpdatedTime(
                                sensorLastUpdated, wl.data.staleDataBufferSec)) {
                              sFormattedTime = wl.app.oMapper.formatHappenedAtDateTime(iHat,
                                tzOffset);
                              bShowStaleIcon = true;
                            }
                            
                            var sensorIconClass = "port-icon icon-" + sensors[j].sensorIconLabel;
                            if (bShowStaleIcon) {
                                sensorIconClass += " stale-icon";
                            }
                            var sensorIconTooltipName = sensors[j].sensorIconTooltip;
                            sensorName = sensorName.replace(/"/g, '&#34;');
                            var sensorIconHtml = this.createPortIconHtml(sensorIconClass, bShowStaleIcon, sFormattedTime, sensorIconTooltipName);
                            sensorListHtml += "<div class='sensor-label'>" + sensorIconHtml + "<span title='" + sensorName +
                              "'>" + sensorName + "</span></div>";
                        }
                        
                        var tilesArr = sensors[j].tiles;
                        for (var k = 0; k < tilesArr.length; k++) {
                            oPortletConfig = this.getPortletConfigByPortletSettingId(tilesArr[k].userPortletSettingId);
                            if (oPortletConfig != null) {
                              sensorListHtml += this.createHtmlOption(
                              'portlet_title_' + tilesArr[k].portletType,
                              oPortletConfig.get('iVisible'),
                              oPortletConfig.get('iLogicalSensorId'),
                              oPortletConfig.get('iPortletSettingId'));
                            }
                        }
                    }
                }  
                sensorListHtml += "</div>";
            }
        }
        this.ui.accordion.append(sensorListHtml);
        this.ui.accordion.accordion("refresh");
    },
    createPortIconHtml: function(iconClass, bDataStale, sFormattedTime, tooltipName) {
      var html = "<i class='" + iconClass +
        "' data-toggle='tooltip' data-container='body' data-html='true' data-placement='bottom' ";
      if (bDataStale) {
        html += "title=\"<div class='last-updated'><span data-l10n-id='last_updated_colon'>Last updated:</span> " +
          sFormattedTime + "</div>\"";
      } else if (tooltipName) {
        html += "title=\"<div>" + tooltipName.replace(/"/g, '&#34;') + "</div>\"";
      }
      html += "></i>";
      return html;
    },
    createHtmlOption: function(sTileName, isVisible, iLogicalSensorId,
      iPortletSettingId) {
      //Check visiblity
      var checked = '';
      var tileOptionClass = 'wl-checkbox';
      var aqiId = wl.data.userAccountSetting.airQualitySchemeId;

      if (isVisible === 1) {
        checked = 'checked="checked"';
      }
      //check for dynamic soil moisture
      if (sTileName.indexOf('portlet_title_structure_type') >= 0 &&
        parseInt(sTileName.split('_').pop()) > 1000) {
        sTileName = 'portlet_title_structure_type_1000';
      }
      //check for aqs
      if (sTileName.indexOf('65') !== -1 && wl.data.aqsSensorData && wl.data.aqsSensorData[iLogicalSensorId]) {
        if (wl.data.aqsSensorData[iLogicalSensorId].additionalData.AQ_ENVIRONMENT === "Indoors" &&
          sTileName.indexOf('temp') === -1 && sTileName.indexOf('hum') === -1) {
          sTileName += '_indoors';
        }
        
        //show 3hr tile for canada and nowcast for others
        if (aqiId === wl.constants.canadaAqiId && sTileName.indexOf('nowcast') !== -1) {
        	tileOptionClass += ' hidden';
        }
        if (aqiId !== wl.constants.canadaAqiId && sTileName.indexOf('3hr') !== -1) {
        	tileOptionClass += ' hidden';
        }
      }

      var tileOptionHtml = '<div class="'+ tileOptionClass +'"><label>';
      tileOptionHtml += '<input type="checkbox" ' +
        ' data-lsid=' + iLogicalSensorId +
        ' data-portSetId=' + iPortletSettingId +
        ' name="tile-' + iPortletSettingId + '"' +
        ' class="js-tile-option" ' + checked + '>';
      tileOptionHtml += '<span class="pseudo-checkbox"></span>';
      tileOptionHtml += '<span data-l10n-id=' + sTileName +
        '></span></label></div>';
      return tileOptionHtml;
    },
    getPortletConfigByLsid: function(iLsid) {
      //Look at the global collection wl.data.portletConfigs and fine the matchign config
      //witht he lsid
      var oMatchedConfig = null;
      wl.data.portletConfigs.each(function(oConfig) {
        if (oConfig.get("iLogicalSensorId") === iLsid) {
          oMatchedConfig = oConfig;
          return false;
        }
      });
      return oMatchedConfig;
    },
    getPortletConfigByPortletTypeId: function(iPortletTypeId) {
      //Look at the global collection wl.data.portletConfigs and fine the matchign config
      //witht he lsid
      var oMatchedConfig = null;
      wl.data.portletConfigs.each(function(oConfig) {
        if (oConfig.get("iPortletTypeId") === iPortletTypeId) {
          oMatchedConfig = oConfig;
          return false;
        }
      });
      return oMatchedConfig;
    },
    getPortletConfigByPortletSettingId: function (iPortletSettingId) {
        var oMatchedConfig = null;
        wl.data.portletConfigs.each(function(oConfig) {
          if (oConfig.get("iPortletSettingId") === iPortletSettingId) {
            oMatchedConfig = oConfig;
            return false;
          }
        });
        return oMatchedConfig;
    }
  });

  var TilePanelListItemView = Marionette.ItemView.extend({
    template: window.tpl['tile-panel-item']
  });

  var TilePanelListCollection = Backbone.Collection.extend({
    comparator: 'iSortOrder'
  });

  var TilePanelListCollectionView = Marionette.CollectionView.extend({
    childView: TilePanelListItemView
  });

  // simple list of node names
  oPanel.NodeListItemView = Marionette.ItemView.extend({
    tagName: 'li',
    template: _.template(
      '<a href="#<%= nodeAnchor %>"><span><%= nodeName %></span></a>'
    ),
    onRender: function() {
      this.$el.children().click(function(e) {
        var $target = $(this.hash);
        if ($target.length) {
          var HEADER_OFFSET = 20;
          $('#scroll-container').animate({
            scrollTop: $target.get(0).offsetTop - HEADER_OFFSET
          });
          return false;
        }
        e.preventDefault();
      });
    }
  });

  oPanel.NodeListCollectionView = Marionette.CollectionView.extend({
    tagName: 'ul',
    className: 'summary-sensor-list',
    childView: oPanel.NodeListItemView
  });

  oPanel.NodeListItemModel = Backbone.Model.extend({
    initialize: function() {
      this.mapNodeName();
    },
    mapNodeName: function() {
      var nodeName = this.get('nodeName');
      var nodeAnchor = nodeName.replace(/[^a-zA-Z0-9_]/g, '-').toLowerCase();
      this.set({
        'nodeAnchor': nodeAnchor,
        'nodeName': nodeName
      });
    }
  });

  oPanel.NodesCollection = Backbone.Collection.extend({
    model: oPanel.NodeListItemModel
  });


  // Initializers
  oPanel.addInitializer(function() {
    this.nodeListView = new oPanel.NodeListView;
    this.rightPanelView = new oPanel.RightPanelView;

    this.nodes = new oPanel.NodesCollection();
    for (var i in wl.data.tilePanelData) {
        if (wl.data.tilePanelData.hasOwnProperty(i)) {
        	if (wl.data.tilePanelData[i].nodeIconLabel !== ''
        		|| wl.__bootstrap_system_info.gatewayTypeAbbrev !== 'SA') {
        		if (wl.data.tilePanelData[i].nodeName != null) {
        			this.nodes.add(wl.data.tilePanelData[i]);
        		}
        	}
        }
    }
    //this.nodes.add(wl.data.tilePanelData.maiaNodeData);
     
//    if (_.isArray(wl.data.tilePanelData)) {
//        var tilePanelData = wl.data.tilePanelData.slice();
//        if (wl.data.maiaSensorData == null || wl.data.maiaSensorData.length === 0) {
//            tilePanelData = _.filter(tilePanelData, {sensorCategory: "default"});
//        }
//        tilePanelData = _.filter(tilePanelData, function (item) {
//            var lsid = _.get(_.find(item.sidebarTiles), 'logicalSensorId');
//            return wl.app.Dashboard.getMaiaLogicalSensorByLsid(lsid) || item.sensorCategory === 'default';
//        });
//        this.nodes.add(tilePanelData);
//    }

    this.nodeListCollectionView = new oPanel.NodeListCollectionView({
      collection: this.nodes
    });

    //layoutView
    wl.app.rightPanel.show(this.rightPanelView);
    if (!wl.app.Dashboard.noPublicData) {
    	this.rightPanelView.getRegion('sensors').show(this.nodeListView);
    }

    this.nodeListCollectionView.render();
    this.nodeListCollectionView.$el.hide();
    $('.wl-dropdown').append(this.nodeListCollectionView.el);
  });

});
